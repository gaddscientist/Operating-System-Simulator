Possible improvements:
1. Mark getters as const??
2. Change member variables to have a preceding m_
3. Change constructors to member initializtion list. important. watch end of video if needed


OVERVIEW:

1. Add all programs to ready queue(until memory/paging comes into play)

BEGIN MAIN LOOP
2. Check interrupt flag to see if last execution stopped because it ended or was interrupted
    2 a) If interrupted, context switch, dispatch process where needed(back to ready queue if quantum, to waiting if IO)
3. If totalProcesses > 0, continue executing processes
    3 a) Dispatch process from head of readyQueue to CPU
    3 b) Execute process until it finishes time slice or hits IO instruction(RR Scheduling)
END MAIN LOOP

PROCESS EXECUTION
1. Change state to RUNNING
2. Get context from pcb(current instruction, which cycle)
    2 a) If CALCULATE instruction, process calculate until time slice ends or instruction finishes
        - If instruction finishes, check if last one. If so, move to terminated queue, state=TERMINATED, totalprocess--
        - Print termination of process w/ process ID(logging/debugging)
    2 b) If IO instruction, have program wait on waitingQueue until IO cycles are finished before moving back to ready queue
        - Consider threading to help with concurrency??

FORKING:
Create job list to hold all processes(by process not pcb)
Overload Process constructor to copy of parent process with no template input
Overload PCB constructor to do the same
Create map/list/vector/deque to hold child processes in Process class
Add fork method to Process class to create new child process
    -Fork method returns child process pcb/pid to be stored in parent

CASCADING TERMINATION:
When parent process is terminated, loop through children setting state to TERMINATED
Afterwards, iterate through ready queue, erasing children
    -If child is not found in ready queue, check waiting queue


MEMORY:
Each process needs a randomized(?) amount of memory assigned to it
Memory should be its own cpp file and will be included via the scheduler or OS
All processes will start in the new queue on OS start up and will then be added to ready queue until its full
To add a process to ready queue, free memory must be larger than total instruction size(?), then decrease free memory
When process is terminated, alotted memory is freed
For cacheing, cpu will have cache that holds up to one full PCB.  Should make this one per core
Cache will be a 5kb store and will decrement with the reqMem of the pcb executing

IO:
Could create separate instructions for different IO, or add functionality into IO threading to reference instruction name(?) and add
    to relevant waiting queue
Threading should still handle IO functionality fine and will block process until process is done sleeping(blocked)

PROCESS MANAGEMENT:
Use 2 core system, each process gets its own thread(?) and while there is a free cpu core, a process is dispatched to it.
Each clock tick the scheduler ensures both cpu core's are executing processes if there are any to execute.

Another idea, each cpu core(subclass of CPU) runs on a separate thread(to simulate physical independence from eachother).  



MULTI-LEVEL PARENT CHILD
Add a number next to the fork instruction for how many levels to create!
